# ch03. 객체지향의 넓이
객체지향에 대한 배경지식을 넓히고 디자인패턴으로 깊이 파자~
## 3.1 객체지향의 기본 요소 5가지
### 객체(Object)
* 객체 : 사람이 인식할 수 있는 최소한의 의미를 가진 사물. 유일한 실체가 있는 사물.
* 객치쟈항에서의 객체 : 최소한의 데이터(속성)와 데이터를 다루는 기능(메소드)을 모두 갖춘 최소한의 독립적인 단위

### 클래스(Class)
* 분류와 범주
  * 일정한 개념에 속하는 모든 객체들의 집합
* 분류와 범주를 통해 세상의 사물과 생명 종류를 추상화(단순화)시켜 바라보게됨

### 속성(Attribute)
* 속성이란
  * 객체가 가지고 있는 고유값. 혹은 변수
* 속성을 잘 추출하는 방법 : 점(객체 하나하나)보다 선(객체간의 협력관계)으로 접근한다.
  * 속성보다는 선의 관점에서 접근해 객체를 바라봐야 한다.
  * 객체가 주어진 역할을 최대한 잘 수행하기 위해서 어떤 기능이 필요할까의 관점으로 접근하자...

### 메소드(Method)
메소드의 객체지향적 활용 방법
* 1단계. 메소드를 함수처럼 쓰기
  * 메소드 안에 로직을 구현하는 것
* 2단계. 메소드에 객체 개념 적용하기
  * 데이터를 효과적으로 추출하는 방법을 알아야 한다..
  * 로직 관점이 아닌 객체 관점으로 시야를 넓게 가진다.
* 3단계. 메소드에 캡슐화 개념 적용하기
  * 속성은 오직 메소드를 통해서만 접근 가능하다 -> 이 규칙을 캡슐화라고 함
  * 메소드는 객체의 속성을 변경하는 통로 역할을 수행함.
  * 속성은 외부 객체가 접근하지 못하게 하고 가능한 메소드를 통해서만 접근하도록 개발해야 함 -> 객체의 무결성과 안정성을 강화
* 4단계. 메소드에 협력 개념 적용하기
  * 다른 객체와 어떻게 상호작용하면 좋을지를 기준으로 설계

### 생성자(Constructor)
* 객체가 처음 생성될 때 호출되는 메소드
* 생성자는 오버로딩 기능을 자주 사용하게 됨

## 3.2 객체지향의 근본 조건 7가지
근본조건 = 사물의 본질이나 원천이 되기 위한 필수 조건. 낮은 관계 의존성, 높은 기능 집중도
### 객체지향 보물지도
* 객체 : 클래스는 코드로 만든 태어날 객체의 설계도 / 객체 - 클래스를 통해 새로 태어난 존재
* 클래스 그룹 : 부모 클래스와 부모 클래스를 상속받은 클래스 구성원들의 그룹. 최상위에 부모 클래스(또는 인터페이스)가 있고, 하위에 특징을 이어받은 자식클래스가 존재
  * 부모클래스(인터페이스) : 클래스 그룹에서 유일하게 존재하는 최상위 클래스
  * 자식클래스(상속클래스) : 부모클래스로부터 속성,기능을 상속받은 클래스
* 클라이언트 클래스(컨텍스트 객체) : 어느 클래스 그룹의 기능을 사용(의존)하는 클래스
* 소프트웨어(프로그램) : 책에서는 소프트웨어와 프로그램을 구분짓지 않고 얘기할거다~

### 상속(세로) (Inheritance)
* 부모 클래스의 무엇인가를 자식 클래스가 물려받는 것
* public > protected > default > private 순으로 상속 범위가 정해짐
  * public : 패키지, 상속 유무 관계 없이 모든곳에서
  * protected : 상속 받은 모든곳(다른 패키지에서도)에서 접근 가능
  * default : 같은 패키지
  * private : 상속받은 클래스도 사용 못함
* 부모와 자식 클래스간 세로로 관계 맺어져 있음. 자식 클래스는 부모 클래스에 강하게 연결되어 있음
* 상속의 효과
  * 코드의 재사용
  * 코드의 수정(확장)의 편리함
  * 개발 편의성 관점
  * 인간에게 익숙한 분류와 범주의 개념 적용
  * 낮은 관계의 의존성과 높은 기능 집중도를 위한 관점
    * 오버라이딩 : 부모 클래스의 기능을 특성에 맞게 오버라이드 할 수 있다. -> 같은 클래스 그룹에서 클래스 고유 특징에 맞게 메소드 로직 구현 가능
    * 폴리모피즘(다형성)

### 오버로딩(Overloading)
* 메소드 이름은 같지만 메소드 인자값을 다르게 해서 같은 메소드 이름을 가져도 별개의 메소드로 보고 접근할 수 있게 하는 기능

### 오버라이딩(Overriding)
* 상속받은 부모 클래스에서 정의한 메소드를 자식클래스 특징에 맞게 로직을 덮어쓰기 해서 재구현하는 개념

### 폴리모피즘(Polymorphism)
* 같은 그룹에 속하는 클래스들의 동일한 메소드를 호출할 때 자식 클래스들이 저마다 다른 로직을 수행하고 리턴하는것
* 클래스가 부모클래스에만 의존하게 하고, 상황에 따라 다른 자식 클래스를 주입하여 실행하도록 하는 것

폴리모피즘 장점
* 관계의 의존성이 낮아짐
  * 부모클래스에만 의존하므로~
* 클라이언트 클래스의 코드 변경 없이 기능 수정/확장이 무제한 가능하다


폴리모피즘으로 구현하지 않는 경우
```java
public class Pilot {
    String code = "";

    public Pilot(String codeReceived) {
        this.code =  codeReceived;
    }

    public void intoAirplane() {
        if (code.equals("프로펠러")) {
            PropellerAirplane pAirplane = new PropellerAirplain();
            pAirplane.airplaneFeature();
        }else if (code.equals("제트")) {
            JetAirplain zAirplane = new ZetAirplain();
            zAirplane.airplaneFeature();
        }
    }
}
```
* 의존성이 심해짐
* 비행기 기능이 변경되거나 확장되면 기존 코드도 따라서 수정되어야 하미....


폴리모피즘(다형성) 원칙 3가지
* 기능을 제공할 비슷한 종류의 클래스를 모아 클래스 그룹으로 조직화 한다
* 기능을 제공할 클래스 그룹의 인터페이스를 통일. 자식클래스는 부모클래스가 사용되는곳에 대체될 수 있어야 함
* 클라이언트 클래스에서는 쓰고싶은 클래스 그룹의 부모 클래스만 의존하고 자식 클래스를 인자로 넘겨받아 저장한다

## Q)
* 상속의 장점이 확장인데 다형성(폴리모피즘)에서는 자식클래스에 로직을 추가하는것을 지양한다는 것이 잘 이해가 되지 않습니다. 객체지향을 위해서 상속과 다형성 사이의 모순을 어떻게 해결할 수 있을까요?

### 캡슐화(Encapsulation)
* 대상을 분리해서 어떤 틀 안에 숨기고 보호한다는 의미
* 관련 있는 여러 정보를 어떤 틀 안에 담는다. -> 외부에 필요 없는 정보들을 노출시키지 않고 숨긴다(정보 은닉)
  * 정보은닉을 하는 이유 : 객체 안의 데이터를 다른 객체가 잘못 조작하는걸 막기 위함

속성의 캡슐화
* 속성을 private 으로 정의해서 Getter/Setter로만 접근가능하도록 함


캡슐화 원칙
* 속성은 private으로 선언
* getter 메소드를 만들어 getter 메소드로만 속성 가져올 수 있도록 정의
* setter 메소드로 데이터를 제한적으로 조작하게 허용하거나 아예 setter 메소드를 제거해서 외부로부터 속성값 조작을 금지함

### 인터페이스(Interface)
* 인터페이스는 클래스의 규칙, 규격을 미리 정의한 모형.
* 인터페이스 하위의 클래스는 인터페이스에 정의된 메소드를 모두 구현해야한다~!!

### 위임(가로)Delegation
* 다형성 측면에서는 로직을 자식에 추가하지 않고 부모에 추가하도록 함. 상속의 장점은 **오버라이딩** 된 확장~..
* 내가 착각한 것 : 상속의 장점은 확장(메소드 추가) -> 그런데 이렇게 메서드 추가 형식의 확장을 하면 프로그램 유지보수가 어려워짐
* 특정 자식클래스에만 적용되는 기술이 추가 확장되어야 할 경우 위임을 사용한다~ -> 기능 인터페이스를 따로 정의하여 새 클래스그룹을 만들고, 해당 인터페이스를 불러와서 수행하는 방식!

## 3.3 객체지향 구현 원리 5가지
### SRP(Single Responsibility Principle)
* 클래스는 하나의 일만 해야 한다는 원칙
* (클래스) 가 자신을 (메서드) 한다. 명제가 반드시 참이여야 함 -> 자기 자신을 스스로 바꿀 수 없는 행동이면 다른 클래스로 분리해야 함

### OCP(Open Closed Principle)
* 수정사항이 생기면 코드를 수정하기 보다는 확장해야 한다. 수정을 하면 사이드이펙트가 생겨 곤혹스러워진다...

### LSP(Liskov Substitution Principle)
* 자식 클래스는 부모 클래스가 사용되는 모든 곳에 대체될 수 있어야 한다 -> 상속받은 자식 객체에 메소드를 추가하지 말아라... 자식 클래스를 직접 호출하지 말아라...
* 상속, 단순위임, 위임을 적절한 상황에 잘 쓰면 LSP를 지키면서 코딩할 수 있다~
  * 상속은 LSP를 만족할 수 있을때만 사용하자. 자식클래스 모든 타입이 100퍼 부모에 대체될 수 있을 때 사용
  * 상속이 필요한데 LSP를 못 지킬 것 같을때는 위임이나 단순위임으로 대체
    * 단순위임은 클래스 기능을 사용은 하는데 바꿀 필요 없을 때 사용
    * 위임은 클래스 기능을 교체할 필요 있을 때 사용

### ISP(Interface Segregation Principle)
* 자기가 쓰지 않는 메소드에 의존하면 안됨!

### DRY(Don't Repeat Yourself)/DIP(Dependency Inversion Principle)
DRY
* 중복된 코드 없애라!


DIP
* 구현클래스 말고 추상클래스에 의존해라!

## Q)
* 자신의 코드가 LSP를 위반했던 케이스를 설명하고, 어떻게 리팩토링 할 수 있을지 작성해주세요
