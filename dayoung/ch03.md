# ch03. 객체지향의 넓이
객체지향에 대한 배경지식을 넓히고 디자인패턴으로 깊이 파자~
## 3.1 객체지향의 기본 요소 5가지
### 객체(Object)
* 객체 : 사람이 인식할 수 있는 최소한의 의미를 가진 사물. 유일한 실체가 있는 사물.
* 객치쟈항에서의 객체 : 최소한의 데이터(속성)와 데이터를 다루는 기능(메소드)을 모두 갖춘 최소한의 독립적인 단위

### 클래스(Class)
* 분류와 범주
  * 일정한 개념에 속하는 모든 객체들의 집합
* 분류와 범주를 통해 세상의 사물과 생명 종류를 추상화(단순화)시켜 바라보게됨

### 속성(Attribute)
* 속성이란
  * 객체가 가지고 있는 고유값. 혹은 변수
* 속성을 잘 추출하는 방법 : 점(객체 하나하나)보다 선(객체간의 협력관계)으로 접근한다.
  * 속성보다는 선의 관점에서 접근해 객체를 바라봐야 한다.
  * 객체가 주어진 역할을 최대한 잘 수행하기 위해서 어떤 기능이 필요할까의 관점으로 접근하자...

### 메소드(Method)
메소드의 객체지향적 활용 방법
* 1단계. 메소드를 함수처럼 쓰기
  * 메소드 안에 로직을 구현하는 것
* 2단계. 메소드에 객체 개념 적용하기
  * 데이터를 효과적으로 추출하는 방법을 알아야 한다..
  * 로직 관점이 아닌 객체 관점으로 시야를 넓게 가진다.
* 3단계. 메소드에 캡슐화 개념 적용하기
  * 속성은 오직 메소드를 통해서만 접근 가능하다 -> 이 규칙을 캡슐화라고 함
  * 메소드는 객체의 속성을 변경하는 통로 역할을 수행함.
  * 속성은 외부 객체가 접근하지 못하게 하고 가능한 메소드를 통해서만 접근하도록 개발해야 함 -> 객체의 무결성과 안정성을 강화
* 4단계. 메소드에 협력 개념 적용하기
  * 다른 객체와 어떻게 상호작용하면 좋을지를 기준으로 설계

### 생성자(Constructor)
* 객체가 처음 생성될 때 호출되는 메소드
* 생성자는 오버로딩 기능을 자주 사용하게 됨

## 3.2 객체지향의 근본 조건 7가지
근본조건 = 사물의 본질이나 원천이 되기 위한 필수 조건. 낮은 관계 의존성, 높은 기능 집중도
### 객체지향 보물지도
* 객체 : 클래스는 코드로 만든 태어날 객체의 설계도 / 객체 - 클래스를 통해 새로 태어난 존재
* 클래스 그룹 : 부모 클래스와 부모 클래스를 상속받은 클래스 구성원들의 그룹. 최상위에 부모 클래스(또는 인터페이스)가 있고, 하위에 특징을 이어받은 자식클래스가 존재
  * 부모클래스(인터페이스) : 클래스 그룹에서 유일하게 존재하는 최상위 클래스
  * 자식클래스(상속클래스) : 부모클래스로부터 속성,기능을 상속받은 클래스
* 클라이언트 클래스(컨텍스트 객체) : 어느 클래스 그룹의 기능을 사용(의존)하는 클래스
* 소프트웨어(프로그램) : 책에서는 소프트웨어와 프로그램을 구분짓지 않고 얘기할거다~

### 상속(세로) (Inheritance)
* 부모 클래스의 무엇인가를 자식 클래스가 물려받는 것
* public > protected > default > private 순으로 상속 범위가 정해짐
  * public : 패키지, 상속 유무 관계 없이 모든곳에서
  * protected : 상속 받은 모든곳(다른 패키지에서도)에서 접근 가능
  * default : 같은 패키지
  * private : 상속받은 클래스도 사용 못함
* 부모와 자식 클래스간 세로로 관계 맺어져 있음. 자식 클래스는 부모 클래스에 강하게 연결되어 있음
* 상속의 효과
  * 코드의 재사용
  * 코드의 수정(확장)의 편리함
  * 개발 편의성 관점
  * 인간에게 익숙한 분류와 범주의 개념 적용
  * 낮은 관계의 의존성과 높은 기능 집중도를 위한 관점
    * 오버라이딩 : 부모 클래스의 기능을 특성에 맞게 오버라이드 할 수 있다. -> 같은 클래스 그룹에서 클래스 고유 특징에 맞게 메소드 로직 구현 가능
    * 폴리모피즘(다형성)

### 오버로딩(Overloading)
* 메소드 이름은 같지만 메소드 인자값을 다르게 해서 같은 메소드 이름을 가져도 별개의 메소드로 보고 접근할 수 있게 하는 기능

### 오버라이딩(Overriding)
* 상속받은 부모 클래스에서 정의한 메소드를 자식클래스 특징에 맞게 로직을 덮어쓰기 해서 재구현하는 개념

### 폴리모피즘(Polymorphism)
* 같은 그룹에 속하는 클래스들의 동일한 메소드를 호출할 때 자식 클래스들이 저마다 다른 로직을 수행하고 리턴하는것
* 클래스가 부모클래스에만 의존하게 하고, 상황에 따라 다른 자식 클래스를 주입하여 실행하도록 하는 것

폴리모피즘 장점
* 관계의 의존성이 낮아짐
  * 부모클래스에만 의존하므로~
* 클라이언트 클래스의 코드 변경 없이 기능 수정/확장이 무제한 가능하다


폴리모피즘으로 구현하지 않는 경우
```java
public class Pilot {
    String code = "";

    public Pilot(String codeReceived) {
        this.code =  codeReceived;
    }

    public void intoAirplane() {
        if (code.equals("프로펠러")) {
            PropellerAirplane pAirplane = new PropellerAirplain();
            pAirplane.airplaneFeature();
        }else if (code.equals("제트")) {
            JetAirplain zAirplane = new ZetAirplain();
            zAirplane.airplaneFeature();
        }
    }
}
```
* 의존성이 심해짐
* 비행기 기능이 변경되거나 확장되면 기존 코드도 따라서 수정되어야 하미....


폴리모피즘(다형성) 원칙 3가지
* 기능을 제공할 비슷한 종류의 클래스를 모아 클래스 그룹으로 조직화 한다
* 기능을 제공할 클래스 그룹의 인터페이스를 통일. 자식클래스는 부모클래스가 사용되는곳에 대체될 수 있어야 함
* 클라이언트 클래스에서는 쓰고싶은 클래스 그룹의 부모 클래스만 의존하고 자식 클래스를 인자로 넘겨받아 저장한다

## Q)
* 상속의 장점이 확장인데 다형성(폴리모피즘)에서는 자식클래스에 로직을 추가하는것을 지양한다는 것이 잘 이해가 되지 않습니다. 객체지향을 위해서 상속과 다형성 사이의 모순을 어떻게 해결할 수 있을까요?

### 캡슐화(Encapsulation)
### 인터페이스(Interface)
### 위임(가로)Delegation

## 3.3 객체지향 구현 원리 5가지
### SRP(Single Responsibility Principle)
### OCP(Open Closed Principle)
### LSP(Liskov Substitution Principle)
### ISP(Interface Segregation Principle)
### DRY(Don't Repeat Yourself)/DIP(Dependency Inversion Principle)
