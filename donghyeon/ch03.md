# Ch03. 객체지향의 넓이

## 객체 지향의 기본 요소 5가지
객체 지향의 기본 요소에 대해 알아보면서 객체 지향을 보는 눈을 넓혀보자.

### 01. 객체(Object)
객체는 사람이 인식할 수 있는 최소한의 의미를 가진 실체가 있는 '유일한' 사물이다. 
객체 지향 프로그래밍의 객체는 속성과 기능이 있는 최소한의 독립적인 단위이다. 이때 실제 객체와 마찬가지로 객체는 '유일한' 실체로 존재한다. 

### 02. 클래스(Class)
우리는 실제 세상을 바라볼 때 분류[^1]와 범주[^2]를 통해 여러 사물과 생명의 종류를 추상화(단순화)한다. 반대로 어떤 분류와 범주에서 구체적인 대상을 표현하는 것을 객체화라고 한다.  
유사한 특징을 가진 대상을 관찰하여 일정하게 묶어 하나의 종류로 정의한 분류와 범주가 클래스이다. 클래스는 앞으로 태어날 객체의 설계도이다.  

### 03. 속성(Attribute)
속성은 객체가 가지고 있는 고윳값이다. 대상의 현실 세계 존재 여부에 따라 속성을 정의하는 방식이 달라진다. 비행기와 같이 실제로 존재하는 객체의 속성을 정의할 때는 객체가 어떤 특징을 가졌는지 관찰한다.
푸시 서비스와 같이 실제로 존재하지 않는 객체의 속성을 정의할 때는 어떤 특징을 부여해야 하는지 고민해야 한다.  
그렇다면 어떻게 하면 속성을 잘 추출할 수 있을까? 바로 `점보다는 선`이다. 객체 하나하나의 속성을 관찰하고 고민하는 것보다는 객체 간의 협력관계에서 어떤 특징(속성)을 나타내는지 관찰하고 고민해야 한다. 이렇게 하면 필연적으로 속성보다 기능을 더 의식하게 된다. 기능(메소드)이 객체의 상호작용을 담당하기 때문이다.  
그리고 너무 완벽한 속성을 추출하기 위해 애쓰는 것 보다 객체의 기능을 잘 발휘할 수 있는 속성을 추출하는 데에 더 집중해야 한다.

### 04. 메소드(Method)
메소드와 함수는 어떻게 다를까? 어떤 일을 수행하는 명령을 하나로 묶고 이름을 부여한 것이 함수이다. 메소드는 객체의 한 조각으로서의 함수이다. 즉, 로직 관점이 아닌 객체 설계 관점에서 객체의 기능(행동)을 정의한 것을 메소드라고 할 수 있다.  
객체지향에서의 속성은 외부로부터의 접근이 차단되어야 한다. 객체의 속성은 오직 메소드로만 접근, 변경되어야 한다. 이를 **캡슐화**라고 한다. 

### 05. 생성자(Constructor)
생성자는 객체가 처음 생성될 때 호출되는 메소드이다. 그래서 객체가 생성되는 순간에 어떤 일을 해야 한다면 생성자에서 구현한다.

## 객체지향의 근본 조건 7가지
객체 지향은 낮은 결합도, 높은 응집도를 달성하기 위한 여러 가지 방법이 있다. 

### 01. 상속(Inheritance)
일상생활에서 사용하는 의미로의 상속이다. 부모 클래스의 속성과 기능을 물려받는 것이다.  
하위 계층은 기본적으로 상위 계층의 특징을 소유하면서, 다시 자신만의 특징을 추가할 수 있다.  
상속은 부모 클래스와 자식 클래스를 강하게 결합한다. 따라서 자식 클래스는 부모 클래스의 특징을 강하게 따라야 한다.  

여러 가지 관점에서 볼 때 상속은 매우 다양한 장점을 갖고 있다. 
코드 관점에서의 상속은 자식 클래스가 부모 클래스의 속성과 기능을 물려받으니 코드의 재사용성이 증가한다. 또한, 클래스 그룹의 코드를 변경해야 한다면 부모 클래스의 코드만 변경하면 되므로 코드의 수정과 확장이 편리해진다. 

개발 편의성 관점에서의 상속은 인간에게 익숙한 분류와 범주의 개념을 적용할 수 있다는 장점이 있다.
마지막으로 객체 지향 관점(낮은 결합도, 높은 응집도)에서의 상속은 앞으로 나올 [[./ch03#03. 오버라이딩(Overriding)|오버라이딩]]과 [[./ch03#04. 다형성(Polymorphism)|다형성]]을 가능하게 한다는 장점이 있다. 

### 02. 오버로딩(Overloading)
메소드의 인자를 다르게 해서, 같은 이름을 가졌지만, 별도의 메소드로 보고 접근할 수 있는 개념이다. 주로 생성자에서 오버로딩을 많이 사용한다. 

### 03. 오버라이딩(Overriding)
부모 클래스의 메소드를 자식 클래스의 특징에 맞게 재정의하는 개념이다. 

### 04. 다형성(Polymorphism)
같은 그룹의 클래스들이 갖는 같은 메소드를 호출할 때 각자 자신의 로직으로 메소드를 수행하는 것이다. 캐릭터에게 공격 명령을 내리면 각자 자신의 직업에 맞게 공격한다. 이것이 다형성이다.
클라이언트 클래스(캐릭터)는 구체적인 하위 클래스들(검, 지팡이, 총 등)이 아니라 최상위 분류(무기)에만 의존하면 되므로 관계의 의존성이 낮아진다. 또한 클라이언트 클래스의 코드 변경 없이 기능의 확장과 수정이 쉬워진다. 캐릭터는 무기의 종류만 바꾸면 총을 쏠 수도 있고, 마법을 쓸 수도 있다. 다른 무기가 추가된다고 해도 캐릭터 클래스는 변경할 필요가 없다. 

다형성은 객체지향의 꽃이라고 불릴 만큼 매우 중요한 요소이다. 이렇게 중요한 다형성을 잘 활용하기 위한 3가지 원칙을 소개한다.
1. '기능을 제공할' 비슷한 종류의 클래스를 모아 조직화한다. 
2. 조직화한 클래스 그룹의 인터페이스를 통일한다. 
3. 클라이언트 클래스에서는 클래스 그룹의 부모 클래스만 의존하고 자식 클래스를 인자로 넘겨받아 저장한다. 


[^1]: 일정한 기준으로 종류에 따라 나누는 일
[^2]: 동일한 성질을 가진 부류나 범위
